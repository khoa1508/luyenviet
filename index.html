<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Luy·ªán Vi·∫øt Ch·ªØ H√°n Realtime</title>
    <style>
        body {
            overscroll-behavior: none; touch-action: none; font-family: sans-serif;
            display: flex; flex-direction: column; align-items: center;
            margin: 0; padding: 10px; background-color: #f0f0f0;
        }
        h1 { color: #333; margin-top: 0; margin-bottom: 10px; }

        .toolbar {
            width: 98%; max-width: 800px; margin-bottom: 10px; padding: 8px;
            background-color: #e0e0e0; border-radius: 5px; display: flex;
            flex-wrap: wrap; gap: 8px; justify-content: center; align-items: center;
        }
        .toolbar button { padding: 6px 10px; border: 1px solid #999; border-radius: 3px; cursor: pointer; background-color: #fff; font-size: 14px; min-width: 40px; height: 30px; box-sizing: border-box; }
        .toolbar button.active { background-color: #a0a0a0; font-weight: bold; border-color: #555; }
        .toolbar button:disabled { cursor: not-allowed; opacity: 0.6; }
        .color-btn { width: 28px; height: 28px; min-width: 28px; padding: 0; border-radius: 50%; border: 2px solid #fff; box-shadow: 1px 1px 2px rgba(0,0,0,0.3); vertical-align: middle; }
        .color-btn.active-color { border-color: #000000; transform: scale(1.1); box-shadow: 2px 2px 4px rgba(0,0,0,0.5); }
        .toolbar .separator { border-left: 1px solid #bbb; height: 25px; margin: 0 5px; }

        #canvas-area {
            display: flex; flex-wrap: wrap; justify-content: center;
            gap: 15px; width: 100%; max-width: 900px; margin-top: 10px;
        }
        #teacher-area { display: flex; flex-direction: column; align-items: center; margin-bottom: 10px; }
        #teacher-area label { font-weight: bold; margin-bottom: 5px; }
        #teacher-canvas { border: 2px solid #333; background-color: #fff; display: block; touch-action: none; }

        #student-area {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px; width: 100%;
        }
        .student-canvas-wrapper { display: flex; flex-direction: column; align-items: center; }
        .student-canvas-wrapper label { font-size: 0.9em; margin-bottom: 3px; }
        .student-canvas {
            border: 1px solid #999; background-color: #fff; display: block;
            width: 100%; height: auto; aspect-ratio: 1 / 1; touch-action: none;
        }
    </style>
    </head>
<body>

    <h1>Luy·ªán Vi·∫øt Ch·ªØ H√°n</h1>

    <div class="toolbar">
        <button id="pen-tool-btn" class="active" title="B√∫t v·∫Ω">‚úèÔ∏è</button>
        <button id="eraser-tool-btn" title="T·∫©y">üßº</button>
        <button id="text-tool-btn" title="Ch·ªØ T">T</button>
        <div class="separator"></div>
        <button class="color-btn" data-color="#000000" style="background-color: #000000;" title="ƒêen"></button>
        <button class="color-btn" data-color="#FF0000" style="background-color: #FF0000;" title="ƒê·ªè"></button>
        <button class="color-btn" data-color="#0000FF" style="background-color: #0000FF;" title="Xanh d∆∞∆°ng"></button>
        <button class="color-btn" data-color="#008000" style="background-color: #008000;" title="Xanh l√°"></button>
        <button class="color-btn" data-color="#FFFF00" style="background-color: #FFFF00;" title="V√†ng"></button>
        <button class="color-btn" data-color="#FFA500" style="background-color: #FFA500;" title="Cam"></button>
        <div class="separator"></div>
        <button id="undo-btn" disabled title="Ho√†n t√°c (GV)">‚Ü©Ô∏è</button>
        <button id="clear-btn" title="X√≥a h·∫øt (GV)">üóëÔ∏è</button>
    </div>

    <div id="canvas-area">
        <div id="teacher-area">
             <label>Gi√°o vi√™n</label>
             <canvas id="teacher-canvas"></canvas>
        </div>
        <div id="student-area">
            <div class="student-canvas-wrapper"> <label>H·ªçc vi√™n 1</label> <canvas id="student-canvas-1" class="student-canvas"></canvas> </div>
            <div class="student-canvas-wrapper"> <label>H·ªçc vi√™n 2</label> <canvas id="student-canvas-2" class="student-canvas"></canvas> </div>
            <div class="student-canvas-wrapper"> <label>H·ªçc vi√™n 3</label> <canvas id="student-canvas-3" class="student-canvas"></canvas> </div>
            <div class="student-canvas-wrapper"> <label>H·ªçc vi√™n 4</label> <canvas id="student-canvas-4" class="student-canvas"></canvas> </div>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        window.addEventListener('load', () => {
            console.log("Kh·ªüi t·∫°o ·ª©ng d·ª•ng b·∫£ng vi·∫øt...");

            // --- Tham chi·∫øu ƒë·∫øn c√°c n√∫t b·∫•m Toolbar ---
            const penBtn = document.getElementById('pen-tool-btn');
            const eraserBtn = document.getElementById('eraser-tool-btn');
            const textBtn = document.getElementById('text-tool-btn');
            const undoBtn = document.getElementById('undo-btn');
            const clearBtn = document.getElementById('clear-btn');
            const colorBtns = document.querySelectorAll('.color-btn');

            // --- K·∫øt n·ªëi Socket.IO ---
            const socket = io();
            socket.on('connect', () => console.log('‚úÖ ƒê√£ k·∫øt n·ªëi Server Socket.IO:', socket.id));
            socket.on('disconnect', () => console.log('‚ùå ƒê√£ ng·∫Øt k·∫øt n·ªëi Server Socket.IO'));

            // --- Bi·∫øn tr·∫°ng th√°i chung ---
            let currentMode = 'draw';
            let currentColor = '#000000';
            let currentLineWidth = 3;
            let currentFont = '16px sans-serif';
            const eraserColor = '#ffffff';
            let activeColorButton = null;

            // --- Undo/History ---
            const MAX_HISTORY_STATES = 20; // *** ƒê√É DI CHUY·ªÇN L√äN ƒê√ÇY ***

            // --- Qu·∫£n l√Ω c√°c Canvas ---
            const canvasElements = document.querySelectorAll('canvas');
            const canvases = {}; // Object ƒë·ªÉ l∆∞u tr·ªØ th√¥ng tin t·ª´ng canvas

            // --- H√†m v·∫Ω l∆∞·ªõi n·ªÅn (Áî∞Â≠óÊ†º) ---
            function drawTianZiGeGrid(ctx, width, height) {
                ctx.save();
                ctx.strokeStyle = '#CCCCCC'; ctx.lineWidth = 0.5;
                ctx.beginPath(); ctx.moveTo(0, height / 2); ctx.lineTo(width, height / 2); ctx.stroke(); // Ngang
                ctx.beginPath(); ctx.moveTo(width / 2, 0); ctx.lineTo(width / 2, height); ctx.stroke(); // D·ªçc
                ctx.restore();
            }

            // --- Kh·ªüi t·∫°o t·ª´ng Canvas ---
            canvasElements.forEach(canvasEl => {
                const canvasId = canvasEl.id;
                 if (!canvasId) { // B·ªè qua n·∫øu canvas kh√¥ng c√≥ ID (v√≠ d·ª•: canvas d√πng b·ªüi th∆∞ vi·ªán kh√°c)
                     console.warn("T√¨m th·∫•y canvas kh√¥ng c√≥ ID, b·ªè qua.");
                     return;
                 }
                const ctx = canvasEl.getContext('2d', { willReadFrequently: true });

                let canvasWidth, canvasHeight;
                if (canvasId === 'teacher-canvas') {
                    canvasWidth = 600; canvasHeight = 450;
                } else if (canvasEl.classList.contains('student-canvas')) {
                    const studentSize = 200;
                    canvasWidth = studentSize; canvasHeight = studentSize;
                } else {
                     canvasWidth = 100; canvasHeight = 100; // M·∫∑c ƒë·ªãnh
                }
                 canvasEl.width = canvasWidth;
                 canvasEl.height = canvasHeight;

                canvases[canvasId] = {
                    element: canvasEl, ctx: ctx, isDrawing: false,
                    lastX: 0, lastY: 0, historyStack: []
                };
                drawGrid(canvasId);
                saveHistoryState(canvasId); // G·ªçi saveHistoryState sau khi MAX_HISTORY_STATES ƒë√£ ƒë∆∞·ª£c khai b√°o

                // G·∫Øn Event Listeners
                canvasEl.addEventListener('mousedown', handleInteractionStart);
                canvasEl.addEventListener('mousemove', handleInteractionMove);
                canvasEl.addEventListener('mouseup', handleInteractionEnd);
                canvasEl.addEventListener('mouseout', handleInteractionEnd);
                canvasEl.addEventListener('touchstart', handleInteractionStart, { passive: false });
                canvasEl.addEventListener('touchmove', handleInteractionMove, { passive: false });
                canvasEl.addEventListener('touchend', handleInteractionEnd);
                canvasEl.addEventListener('touchcancel', handleInteractionEnd);
                console.log(`ƒê√£ kh·ªüi t·∫°o canvas: ${canvasId} (${canvasEl.width}x${canvasEl.height})`);
            });

            // --- H√†m v·∫Ω l·∫°i l∆∞·ªõi ---
             function drawGrid(canvasId) { if (canvases[canvasId]) { const { ctx, element } = canvases[canvasId]; drawTianZiGeGrid(ctx, element.width, element.height); } }

            // --- Qu·∫£n l√Ω History (c·∫ßn canvasId) ---
            function saveHistoryState(canvasId) { if (!canvases[canvasId]) return; const { ctx, element, historyStack } = canvases[canvasId]; try { const imageData = ctx.getImageData(0, 0, element.width, element.height); historyStack.push(imageData); if (historyStack.length > MAX_HISTORY_STATES) { historyStack.shift(); } if (canvasId === 'teacher-canvas') updateUndoButtonState(); } catch (error) { console.error(`L·ªói khi l∆∞u history cho ${canvasId}:`, error);}}
            function undoLastAction() { const canvasId = 'teacher-canvas'; if (!canvases[canvasId]) return; const { historyStack } = canvases[canvasId]; if (historyStack.length <= 1) return; historyStack.pop(); redrawLastState(canvasId); updateUndoButtonState(); console.log(`Ho√†n t√°c tr√™n ${canvasId}`); }
            function redrawLastState(canvasId) { if (!canvases[canvasId]) return; const { ctx, historyStack, element } = canvases[canvasId]; ctx.clearRect(0, 0, element.width, element.height); drawGrid(canvasId); if (historyStack.length > 0) { const lastState = historyStack[historyStack.length - 1]; try { ctx.putImageData(lastState, 0, 0); } catch (error) { console.error(`L·ªói khi v·∫Ω l·∫°i state cho ${canvasId}:`, error); } } drawGrid(canvasId); }
            function updateUndoButtonState() { if (canvases['teacher-canvas']) undoBtn.disabled = (canvases['teacher-canvas'].historyStack.length <= 1); else undoBtn.disabled = true; }

            // --- X√≥a Canvas ---
             function clearCanvasLocal(canvasId) { if (!canvases[canvasId]) return; const { ctx, element } = canvases[canvasId]; ctx.clearRect(0, 0, element.width, element.height); drawGrid(canvasId); canvases[canvasId].historyStack = []; saveHistoryState(canvasId); if (canvasId === 'teacher-canvas') updateUndoButtonState(); }
             function clearTeacherCanvasAndEmit() { const canvasId = 'teacher-canvas'; if (confirm(`B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a n·ªôi dung √¥ ${canvasId}? H√†nh ƒë·ªông n√†y c≈©ng s·∫Ω x√≥a t·∫•t c·∫£ c√°c √¥ kh√°c.`)) { socket.emit('clear_action'); console.log("Y√™u c·∫ßu x√≥a t·∫•t c·∫£."); }}

            // --- L·∫•y t·ªça ƒë·ªô chu·∫©n h√≥a (C·∫ßn e.target) ---
            function getCoordinates(e) { let x, y; const targetCanvas = e.target; if (!targetCanvas || typeof targetCanvas.getBoundingClientRect !== 'function') { console.error("L·ªói l·∫•y target canvas trong getCoordinates"); return { x: 0, y: 0 }; } const rect = targetCanvas.getBoundingClientRect(); if (e.touches && e.touches.length > 0) { x = e.touches[0].clientX - rect.left; y = e.touches[0].clientY - rect.top; } else if (e.changedTouches && e.changedTouches.length > 0) { x = e.changedTouches[0].clientX - rect.left; y = e.changedTouches[0].clientY - rect.top; } else { x = e.clientX - rect.left; y = e.clientY - rect.top; } return { x, y }; }

             // --- V·∫Ω/T·∫©y/Ch·ªØ t·ª´ d·ªØ li·ªáu (c·∫ßn ctx) ---
             function drawSegmentOnCtx(ctx, data) { const { x1, y1, x2, y2, color, width } = data; ctx.save(); ctx.strokeStyle = color; ctx.lineWidth = width; ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke(); ctx.restore(); }
             function drawTextOnCtx(ctx, data) { const { text, x, y, color, font } = data; ctx.save(); ctx.fillStyle = color; ctx.font = font; ctx.textAlign = 'left'; ctx.textBaseline = 'top'; ctx.fillText(text, x, y); ctx.restore(); }

            // --- C·∫≠p nh·∫≠t UI Toolbar ---
             function updateToolUI() { penBtn.classList.remove('active'); eraserBtn.classList.remove('active'); textBtn.classList.remove('active'); if (currentMode === 'draw') penBtn.classList.add('active'); else if (currentMode === 'eraser') eraserBtn.classList.add('active'); else if (currentMode === 'text') textBtn.classList.add('active'); colorBtns.forEach(btn => btn.classList.remove('active-color')); if (activeColorButton) activeColorButton.classList.add('active-color'); }

            // --- G·∫Øn s·ª± ki·ªán n√∫t Toolbar ---
            penBtn.addEventListener('click', () => { currentMode = 'draw'; updateToolUI(); }); eraserBtn.addEventListener('click', () => { currentMode = 'eraser'; updateToolUI(); }); textBtn.addEventListener('click', () => { currentMode = 'text'; updateToolUI(); }); undoBtn.addEventListener('click', undoLastAction); clearBtn.addEventListener('click', clearTeacherCanvasAndEmit);
            colorBtns.forEach(btn => { btn.addEventListener('click', () => { currentColor = btn.dataset.color; activeColorButton = btn; currentMode = 'draw'; updateToolUI(); }); });

            // --- X·ª≠ l√Ω t∆∞∆°ng t√°c (Start, Move, End) ---
            function handleInteractionStart(e) { if (e.type === 'touchstart') e.preventDefault(); const targetCanvas = e.target; const canvasId = targetCanvas.id; if (!canvases[canvasId]) return; const coords = getCoordinates(e); const state = canvases[canvasId]; if (currentMode === 'draw' || currentMode === 'eraser') { state.isDrawing = true; state.lastX = coords.x; state.lastY = coords.y; drawDotOnCtx(state.ctx, state.lastX, state.lastY); } else if (currentMode === 'text') { placeText(coords, canvasId); } }
            function drawDotOnCtx(ctx, x, y) { ctx.save(); ctx.beginPath(); ctx.fillStyle = (currentMode === 'eraser') ? eraserColor : currentColor; ctx.arc(x, y, currentLineWidth / 2, 0, Math.PI * 2); ctx.fill(); ctx.restore();}
            function handleInteractionMove(e) { if (e.type === 'touchmove') e.preventDefault(); const targetCanvas = e.target; const canvasId = targetCanvas.id; if (!canvases[canvasId]) return; const state = canvases[canvasId]; if (!state.isDrawing) return; const coords = getCoordinates(e); const x2 = coords.x; const y2 = coords.y; const drawData = { canvasId: canvasId, mode: currentMode, x1: state.lastX, y1: state.lastY, x2: x2, y2: y2, color: (currentMode === 'eraser') ? eraserColor : currentColor, width: currentLineWidth }; drawSegmentOnCtx(state.ctx, drawData); socket.emit('draw_action', drawData); state.lastX = x2; state.lastY = y2;}
            function handleInteractionEnd(e) { const targetCanvas = e.target; const canvasId = targetCanvas.id; if (!canvases[canvasId]) return; const state = canvases[canvasId]; if (state.isDrawing) { state.isDrawing = false; saveHistoryState(canvasId); }}
            function placeText(coords, canvasId) { if (!canvases[canvasId]) return; const { ctx } = canvases[canvasId]; const text = prompt("Nh·∫≠p vƒÉn b·∫£n:"); if (text) { const textData = { canvasId: canvasId, text: text, x: coords.x, y: coords.y, color: currentColor, font: currentFont }; drawTextOnCtx(ctx, textData); saveHistoryState(canvasId); socket.emit('text_action', textData); console.log(`ƒê√£ th√™m ch·ªØ v√†o ${canvasId} v√† g·ª≠i`); } else { console.log("ƒê√£ h·ªßy th√™m ch·ªØ."); }}

            // --- G·∫Øn c√°c Event Listeners (ƒê√£ g·∫Øn trong v√≤ng l·∫∑p kh·ªüi t·∫°o) ---

             // --- L·∫ÆNG NGHE S·ª∞ KI·ªÜN T·ª™ SERVER ---
             socket.on('draw_action', (data) => { console.log(`<< Nh·∫≠n draw_action cho ${data.canvasId}`); const targetCanvasInfo = canvases[data.canvasId]; if (targetCanvasInfo) drawSegmentOnCtx(targetCanvasInfo.ctx, data); else console.warn(`Kh√¥ng t√¨m th·∫•y canvas ID: ${data.canvasId}`); });
             socket.on('text_action', (data) => { console.log(`<< Nh·∫≠n text_action cho ${data.canvasId}`); const targetCanvasInfo = canvases[data.canvasId]; if (targetCanvasInfo) drawTextOnCtx(targetCanvasInfo.ctx, data); else console.warn(`Kh√¥ng t√¨m th·∫•y canvas ID: ${data.canvasId}`); });
             socket.on('clear_action', () => { console.log('<< Nh·∫≠n clear_action (x√≥a t·∫•t c·∫£)'); Object.keys(canvases).forEach(id => clearCanvasLocal(id)); });

            // --- Kh·ªüi t·∫°o cu·ªëi c√πng ---
            activeColorButton = document.querySelector('.color-btn[data-color="#000000"]');
            updateToolUI();
            updateUndoButtonState();
            console.log("·ª®ng d·ª•ng Luy·ªán Vi·∫øt Ch·ªØ H√°n (Multi-Canvas) ƒë√£ s·∫µn s√†ng!");

        });
    // ==================== JAVASCRIPT K·∫æT TH√öC ====================
    </script>

</body>
</html>
